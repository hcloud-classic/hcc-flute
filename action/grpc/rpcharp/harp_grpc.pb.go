// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpcharp

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// HarpClient is the client API for Harp service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HarpClient interface {
	// Subnet
	CreateSubnet(ctx context.Context, in *Subnet, opts ...grpc.CallOption) (*Subnet, error)
	GetSubnet(ctx context.Context, in *ReqHarp, opts ...grpc.CallOption) (*ResHarp, error)
	GetSubnetList(ctx context.Context, in *GetSubnetListRequest, opts ...grpc.CallOption) (*SubnetList, error)
	GetSubnetNum(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SubnetNum, error)
	UpdateSubnet(ctx context.Context, in *Subnet, opts ...grpc.CallOption) (*Subnet, error)
	DeleteSubnet(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*UUID, error)
	// AdaptiveIP
	CreateAdaptiveIPSetting(ctx context.Context, in *AdaptiveIPSetting, opts ...grpc.CallOption) (*AdaptiveIPSetting, error)
	GetAdaptiveIPSetting(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AdaptiveIPSetting, error)
	GetAdaptiveIPAvailableIPList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AdaptiveIPAvailableIPList, error)
	CreateAdaptiveIPServer(ctx context.Context, in *CreateAdaptiveIPServerRequest, opts ...grpc.CallOption) (*AdaptiveIPServer, error)
	GetAdaptiveIPServer(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*AdaptiveIPServer, error)
	GetAdaptiveIPServerList(ctx context.Context, in *GetAdaptiveIPServerListRequest, opts ...grpc.CallOption) (*AdaptiveIPServerList, error)
	GetAdaptiveIPServerNum(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AdaptiveIPServerNum, error)
	DeleteAdaptiveIPServer(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*UUID, error)
	// DHCPD
	CreateDHPCDConf(ctx context.Context, in *CreateDHPCDConfRequest, opts ...grpc.CallOption) (*Result, error)
}

type harpClient struct {
	cc grpc.ClientConnInterface
}

func NewHarpClient(cc grpc.ClientConnInterface) HarpClient {
	return &harpClient{cc}
}

func (c *harpClient) CreateSubnet(ctx context.Context, in *Subnet, opts ...grpc.CallOption) (*Subnet, error) {
	out := new(Subnet)
	err := c.cc.Invoke(ctx, "/pb.Harp/CreateSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetSubnet(ctx context.Context, in *ReqHarp, opts ...grpc.CallOption) (*ResHarp, error) {
	out := new(ResHarp)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetSubnetList(ctx context.Context, in *GetSubnetListRequest, opts ...grpc.CallOption) (*SubnetList, error) {
	out := new(SubnetList)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetSubnetList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetSubnetNum(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SubnetNum, error) {
	out := new(SubnetNum)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetSubnetNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) UpdateSubnet(ctx context.Context, in *Subnet, opts ...grpc.CallOption) (*Subnet, error) {
	out := new(Subnet)
	err := c.cc.Invoke(ctx, "/pb.Harp/UpdateSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) DeleteSubnet(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*UUID, error) {
	out := new(UUID)
	err := c.cc.Invoke(ctx, "/pb.Harp/DeleteSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) CreateAdaptiveIPSetting(ctx context.Context, in *AdaptiveIPSetting, opts ...grpc.CallOption) (*AdaptiveIPSetting, error) {
	out := new(AdaptiveIPSetting)
	err := c.cc.Invoke(ctx, "/pb.Harp/CreateAdaptiveIPSetting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetAdaptiveIPSetting(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AdaptiveIPSetting, error) {
	out := new(AdaptiveIPSetting)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetAdaptiveIPSetting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetAdaptiveIPAvailableIPList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AdaptiveIPAvailableIPList, error) {
	out := new(AdaptiveIPAvailableIPList)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetAdaptiveIPAvailableIPList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) CreateAdaptiveIPServer(ctx context.Context, in *CreateAdaptiveIPServerRequest, opts ...grpc.CallOption) (*AdaptiveIPServer, error) {
	out := new(AdaptiveIPServer)
	err := c.cc.Invoke(ctx, "/pb.Harp/CreateAdaptiveIPServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetAdaptiveIPServer(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*AdaptiveIPServer, error) {
	out := new(AdaptiveIPServer)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetAdaptiveIPServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetAdaptiveIPServerList(ctx context.Context, in *GetAdaptiveIPServerListRequest, opts ...grpc.CallOption) (*AdaptiveIPServerList, error) {
	out := new(AdaptiveIPServerList)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetAdaptiveIPServerList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) GetAdaptiveIPServerNum(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AdaptiveIPServerNum, error) {
	out := new(AdaptiveIPServerNum)
	err := c.cc.Invoke(ctx, "/pb.Harp/GetAdaptiveIPServerNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) DeleteAdaptiveIPServer(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*UUID, error) {
	out := new(UUID)
	err := c.cc.Invoke(ctx, "/pb.Harp/DeleteAdaptiveIPServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *harpClient) CreateDHPCDConf(ctx context.Context, in *CreateDHPCDConfRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/pb.Harp/CreateDHPCDConf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HarpServer is the server API for Harp service.
// All implementations must embed UnimplementedHarpServer
// for forward compatibility
type HarpServer interface {
	// Subnet
	CreateSubnet(context.Context, *Subnet) (*Subnet, error)
	GetSubnet(context.Context, *ReqHarp) (*ResHarp, error)
	GetSubnetList(context.Context, *GetSubnetListRequest) (*SubnetList, error)
	GetSubnetNum(context.Context, *Empty) (*SubnetNum, error)
	UpdateSubnet(context.Context, *Subnet) (*Subnet, error)
	DeleteSubnet(context.Context, *UUID) (*UUID, error)
	// AdaptiveIP
	CreateAdaptiveIPSetting(context.Context, *AdaptiveIPSetting) (*AdaptiveIPSetting, error)
	GetAdaptiveIPSetting(context.Context, *Empty) (*AdaptiveIPSetting, error)
	GetAdaptiveIPAvailableIPList(context.Context, *Empty) (*AdaptiveIPAvailableIPList, error)
	CreateAdaptiveIPServer(context.Context, *CreateAdaptiveIPServerRequest) (*AdaptiveIPServer, error)
	GetAdaptiveIPServer(context.Context, *UUID) (*AdaptiveIPServer, error)
	GetAdaptiveIPServerList(context.Context, *GetAdaptiveIPServerListRequest) (*AdaptiveIPServerList, error)
	GetAdaptiveIPServerNum(context.Context, *Empty) (*AdaptiveIPServerNum, error)
	DeleteAdaptiveIPServer(context.Context, *UUID) (*UUID, error)
	// DHCPD
	CreateDHPCDConf(context.Context, *CreateDHPCDConfRequest) (*Result, error)
	mustEmbedUnimplementedHarpServer()
}

// UnimplementedHarpServer must be embedded to have forward compatible implementations.
type UnimplementedHarpServer struct {
}

func (*UnimplementedHarpServer) CreateSubnet(context.Context, *Subnet) (*Subnet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubnet not implemented")
}
func (*UnimplementedHarpServer) GetSubnet(context.Context, *ReqHarp) (*ResHarp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubnet not implemented")
}
func (*UnimplementedHarpServer) GetSubnetList(context.Context, *GetSubnetListRequest) (*SubnetList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubnetList not implemented")
}
func (*UnimplementedHarpServer) GetSubnetNum(context.Context, *Empty) (*SubnetNum, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubnetNum not implemented")
}
func (*UnimplementedHarpServer) UpdateSubnet(context.Context, *Subnet) (*Subnet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubnet not implemented")
}
func (*UnimplementedHarpServer) DeleteSubnet(context.Context, *UUID) (*UUID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubnet not implemented")
}
func (*UnimplementedHarpServer) CreateAdaptiveIPSetting(context.Context, *AdaptiveIPSetting) (*AdaptiveIPSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAdaptiveIPSetting not implemented")
}
func (*UnimplementedHarpServer) GetAdaptiveIPSetting(context.Context, *Empty) (*AdaptiveIPSetting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdaptiveIPSetting not implemented")
}
func (*UnimplementedHarpServer) GetAdaptiveIPAvailableIPList(context.Context, *Empty) (*AdaptiveIPAvailableIPList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdaptiveIPAvailableIPList not implemented")
}
func (*UnimplementedHarpServer) CreateAdaptiveIPServer(context.Context, *CreateAdaptiveIPServerRequest) (*AdaptiveIPServer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAdaptiveIPServer not implemented")
}
func (*UnimplementedHarpServer) GetAdaptiveIPServer(context.Context, *UUID) (*AdaptiveIPServer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdaptiveIPServer not implemented")
}
func (*UnimplementedHarpServer) GetAdaptiveIPServerList(context.Context, *GetAdaptiveIPServerListRequest) (*AdaptiveIPServerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdaptiveIPServerList not implemented")
}
func (*UnimplementedHarpServer) GetAdaptiveIPServerNum(context.Context, *Empty) (*AdaptiveIPServerNum, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdaptiveIPServerNum not implemented")
}
func (*UnimplementedHarpServer) DeleteAdaptiveIPServer(context.Context, *UUID) (*UUID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAdaptiveIPServer not implemented")
}
func (*UnimplementedHarpServer) CreateDHPCDConf(context.Context, *CreateDHPCDConfRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDHPCDConf not implemented")
}
func (*UnimplementedHarpServer) mustEmbedUnimplementedHarpServer() {}

func RegisterHarpServer(s *grpc.Server, srv HarpServer) {
	s.RegisterService(&_Harp_serviceDesc, srv)
}

func _Harp_CreateSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subnet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).CreateSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/CreateSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).CreateSubnet(ctx, req.(*Subnet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqHarp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetSubnet(ctx, req.(*ReqHarp))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetSubnetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubnetListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetSubnetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetSubnetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetSubnetList(ctx, req.(*GetSubnetListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetSubnetNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetSubnetNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetSubnetNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetSubnetNum(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_UpdateSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subnet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).UpdateSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/UpdateSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).UpdateSubnet(ctx, req.(*Subnet))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_DeleteSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).DeleteSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/DeleteSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).DeleteSubnet(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_CreateAdaptiveIPSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdaptiveIPSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).CreateAdaptiveIPSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/CreateAdaptiveIPSetting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).CreateAdaptiveIPSetting(ctx, req.(*AdaptiveIPSetting))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetAdaptiveIPSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetAdaptiveIPSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetAdaptiveIPSetting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetAdaptiveIPSetting(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetAdaptiveIPAvailableIPList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetAdaptiveIPAvailableIPList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetAdaptiveIPAvailableIPList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetAdaptiveIPAvailableIPList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_CreateAdaptiveIPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAdaptiveIPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).CreateAdaptiveIPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/CreateAdaptiveIPServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).CreateAdaptiveIPServer(ctx, req.(*CreateAdaptiveIPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetAdaptiveIPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetAdaptiveIPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetAdaptiveIPServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetAdaptiveIPServer(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetAdaptiveIPServerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdaptiveIPServerListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetAdaptiveIPServerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetAdaptiveIPServerList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetAdaptiveIPServerList(ctx, req.(*GetAdaptiveIPServerListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_GetAdaptiveIPServerNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).GetAdaptiveIPServerNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/GetAdaptiveIPServerNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).GetAdaptiveIPServerNum(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_DeleteAdaptiveIPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).DeleteAdaptiveIPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/DeleteAdaptiveIPServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).DeleteAdaptiveIPServer(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Harp_CreateDHPCDConf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDHPCDConfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HarpServer).CreateDHPCDConf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Harp/CreateDHPCDConf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HarpServer).CreateDHPCDConf(ctx, req.(*CreateDHPCDConfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Harp_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Harp",
	HandlerType: (*HarpServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSubnet",
			Handler:    _Harp_CreateSubnet_Handler,
		},
		{
			MethodName: "GetSubnet",
			Handler:    _Harp_GetSubnet_Handler,
		},
		{
			MethodName: "GetSubnetList",
			Handler:    _Harp_GetSubnetList_Handler,
		},
		{
			MethodName: "GetSubnetNum",
			Handler:    _Harp_GetSubnetNum_Handler,
		},
		{
			MethodName: "UpdateSubnet",
			Handler:    _Harp_UpdateSubnet_Handler,
		},
		{
			MethodName: "DeleteSubnet",
			Handler:    _Harp_DeleteSubnet_Handler,
		},
		{
			MethodName: "CreateAdaptiveIPSetting",
			Handler:    _Harp_CreateAdaptiveIPSetting_Handler,
		},
		{
			MethodName: "GetAdaptiveIPSetting",
			Handler:    _Harp_GetAdaptiveIPSetting_Handler,
		},
		{
			MethodName: "GetAdaptiveIPAvailableIPList",
			Handler:    _Harp_GetAdaptiveIPAvailableIPList_Handler,
		},
		{
			MethodName: "CreateAdaptiveIPServer",
			Handler:    _Harp_CreateAdaptiveIPServer_Handler,
		},
		{
			MethodName: "GetAdaptiveIPServer",
			Handler:    _Harp_GetAdaptiveIPServer_Handler,
		},
		{
			MethodName: "GetAdaptiveIPServerList",
			Handler:    _Harp_GetAdaptiveIPServerList_Handler,
		},
		{
			MethodName: "GetAdaptiveIPServerNum",
			Handler:    _Harp_GetAdaptiveIPServerNum_Handler,
		},
		{
			MethodName: "DeleteAdaptiveIPServer",
			Handler:    _Harp_DeleteAdaptiveIPServer_Handler,
		},
		{
			MethodName: "CreateDHPCDConf",
			Handler:    _Harp_CreateDHPCDConf_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "harp.proto",
}
